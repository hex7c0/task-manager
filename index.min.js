"use strict";

function resume(sock) {
    return sock.resume();
}

function wrapper(my) {
    function start(print) {
        return server.listen(my.listen, function() {
            print && console.log("task manager bound at " + my.listen);
        });
    }
    var output = function() {};
    my.output && (output = function(consolle) {
        return console.log(consolle);
    });
    var next = function(sock, string) {
        sock.write(string, function() {
            return sock.resume();
        });
    };
    my.json && (next = function(sock, string, object) {
        sock.write(JSON.stringify(object), function() {
            return sock.resume();
        });
    });
    var path = __dirname + "/min/lib/", mod = Object.create(null);
    fs.readdirSync(path).forEach(function(module) {
        mod[module] = require(path + module);
    });
    var server = net.createServer(function(sock) {
        var grant = !1;
        return my.auth ? grant ? sock.write("> hello master\n", function() {
            return output("client connected");
        }) : sock.write("> auth required\n") : sock.write("> hello master\n"), sock.on("end", function() {
            return my.auth && (grant = !1), output("client disconnected");
        }).on("data", function(buff) {
            sock.pause();
            var index, command = String(buff), workers = cluster.workers;
            if (my.auth && grant === !1) return void (command.replace(/(\n)*(\r)*/g, "") === my.auth ? (grant = !0, 
            sock.write("> hello master\n", function() {
                return output("client connected"), resume(sock);
            })) : sock.write("> auth required\n", function() {
                return output("client denied"), resume(sock);
            }));
            for (var m in mod) if (mod[m].regex.test(command) === !0) return mod[m].body(sock, command, workers, next);
            return my.custom && my.custom.test(command) ? (my.callback(sock, command), resume(sock)) : /^exit[\r]?\n$/.test(command) ? (sock.end("> exit\n", function() {
                return server.close(function() {
                    return output("exit");
                });
            }), process.exit(0)) : /^close[\r]?\n$/.test(command) ? sock.end("> close\n", function() {
                return server.close(function() {
                    return output("close");
                });
            }) : /^help[\r]?\n$/.test(command) ? (index = "  disconnect [pid]\n", index += "  fork\n", 
            index += "  kill [pid]\n", index += "  memory\n", index += "  ps\n", index += "  title [name]\n", 
            index += "  uptime\n", index += "  exit\n", index += "  close\n", sock.write(index, function() {
                return resume(sock);
            })) : /^nyan[\r]?\n$/.test(command) ? (index = "-_-_-_-_-_-_-_,------,      o      \n", 
            index += "_-_-_-_-_-_-_-|   /\\_/\\            \n", index += "-_-_-_-_-_-_-~|__( ^ .^)  +     +  \n", 
            index += '_-_-_-_-_-_-_-""  ""               \n', sock.write(index, function() {
                return resume(sock);
            })) : sock.write('> unrecognized, try "help"\n', function() {
                return resume(sock);
            });
        });
    });
    return server.on("error", function(e) {
        "EADDRINUSE" === e.code && (isNaN(my.listen) ? fs.unlink(my.listen, function(err) {
            if (err) throw err;
            return start(!1);
        }) : setTimeout(function() {
            return start(!1);
        }, 1e3));
    }), start(!0);
}

function task(listen, opt) {
    if (!listen) throw new TypeError("listen required");
    var what = Number(listen) || String(listen), options = opt || Object.create(null), my = {
        listen: what,
        output: options.output === !0 ? !0 : !1,
        auth: Boolean(options.auth) ? String(options.auth) : !1,
        custom: Boolean(options.custom) ? options.custom : !1,
        callback: options.callback,
        json: Boolean(options.json)
    };
    return my.custom && "function" == typeof my.callback ? my.custom.source || (my.custom = new RegExp(my.custom)) : my.custom = !1, 
    wrapper(my);
}

try {
    var cluster = require("cluster"), fs = require("fs"), net = require("net");
} catch (MODULE_NOT_FOUND) {
    console.error(MODULE_NOT_FOUND), process.exit(1);
}

module.exports = task;

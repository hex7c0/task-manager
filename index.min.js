"use strict";

var cluster = require("cluster"), fs = require("fs"), commandRegex = /(\r)*(\n)*/g, exitRegex = /^exit[\r]?\n$/i, closeRegex = /^close[\r]?\n$/i, helpRegex = /^help[\r]?\n$/i, nyanRegex = /^nyan[\r]?\n$/;

function load() {
    var path = __dirname + "/min/lib/", mod = Object.create(null);
    return fs.readdirSync(path).forEach(function(module) {
        mod[module] = require(path + module);
    }), mod;
}

function wrapperTLS(my) {
    var tls = require("tls"), mod = load(), keys = Object.keys(mod), ii = keys.length, output = function() {};
    my.output && (output = function(consolle) {
        return console.log(consolle);
    });
    function resume(sock) {
        return sock.resume();
    }
    var next = function(sock, string) {
        sock.write(string, function() {
            return sock.resume();
        });
    };
    my.json && (next = function(sock, string, object) {
        sock.write(JSON.stringify(object), function() {
            return sock.resume();
        });
    });
    function start(print) {
        return server.listen(my.listen, function() {
            print && console.log("task manager bound at TLS:" + my.listen);
        });
    }
    var server = tls.createServer(my.tls, function(sock) {
        var grant = !1;
        return my.auth ? grant ? sock.write("> hello master\n", function() {
            return output("client connected");
        }) : sock.write("> auth required\n") : sock.write("> hello master\n"), sock.on("end", function() {
            return my.auth && (grant = !1), output("client disconnected");
        }).on("data", function(buff) {
            sock.pause();
            var index, command = String(buff), workers = cluster.workers;
            if (!my.auth || !1 !== grant) {
                for (var i = 0; i < ii; ++i) {
                    var m = mod[keys[i]];
                    if (!0 === m.regex.test(command)) return m.body(sock, command, workers, next);
                }
                return my.custom && my.custom.test(command) ? (my.callback(sock, command), resume(sock)) : exitRegex.test(command) ? (sock.end("> exit\n", function() {
                    return server.close(function() {
                        return output("exit");
                    });
                }), process.exit(0)) : closeRegex.test(command) ? sock.end("> close\n", function() {
                    return server.close(function() {
                        return output("close");
                    });
                }) : helpRegex.test(command) ? (index = "  disconnect [pid]\n", index += "  fork\n", 
                index += "  kill [pid]\n", index += "  memory\n", index += "  ps\n", index += "  title [name]\n", 
                index += "  uptime\n", index += "  exit\n", index += "  close\n", sock.write(index, function() {
                    return resume(sock);
                })) : nyanRegex.test(command) ? (index = "-_-_-_-_-_-_-_,------,      o      \n", 
                index += "_-_-_-_-_-_-_-|   /\\_/\\            \n", index += "-_-_-_-_-_-_-~|__( ^ .^)  +     +  \n", 
                index += '_-_-_-_-_-_-_-""  ""               \n', sock.write(index, function() {
                    return resume(sock);
                })) : sock.write('> unrecognized, try "help"\n', function() {
                    return resume(sock);
                });
            }
            command.replace(commandRegex, "") === my.auth ? (grant = !0, sock.write("> hello master\n", function() {
                return output("client connected"), resume(sock);
            })) : sock.write("> auth required\n", function() {
                return output("client denied"), resume(sock);
            });
        });
    });
    return server.on("error", function(e) {
        "EADDRINUSE" !== e.code && "ECONNREFUSED" !== e.code || setTimeout(function() {
            return start(!1);
        }, 1e3);
    }), start(!0);
}

function wrapperTCP(my) {
    var net = require("net"), mod = load(), keys = Object.keys(mod), ii = keys.length, output = function() {};
    my.output && (output = function(consolle) {
        return console.log(consolle);
    });
    function resume(sock) {
        return sock.resume();
    }
    var next = function(sock, string) {
        sock.write(string, function() {
            return sock.resume();
        });
    };
    my.json && (next = function(sock, string, object) {
        sock.write(JSON.stringify(object), function() {
            return sock.resume();
        });
    });
    function start(print) {
        return server.listen(my.listen, function() {
            print && console.log("task manager bound at TCP:" + my.listen);
        });
    }
    var server = net.createServer(function(sock) {
        var grant = !1;
        return my.auth ? grant ? sock.write("> hello master\n", function() {
            return output("client connected");
        }) : sock.write("> auth required\n") : sock.write("> hello master\n"), sock.on("end", function() {
            return my.auth && (grant = !1), output("client disconnected");
        }).on("data", function(buff) {
            sock.pause();
            var index, command = String(buff), workers = cluster.workers;
            if (!my.auth || !1 !== grant) {
                for (var i = 0; i < ii; ++i) {
                    var m = mod[keys[i]];
                    if (!0 === m.regex.test(command)) return m.body(sock, command, workers, next);
                }
                return my.custom && my.custom.test(command) ? (my.callback(sock, command), resume(sock)) : exitRegex.test(command) ? (sock.end("> exit\n", function() {
                    return server.close(function() {
                        return output("exit");
                    });
                }), process.exit(0)) : closeRegex.test(command) ? sock.end("> close\n", function() {
                    return server.close(function() {
                        return output("close");
                    });
                }) : helpRegex.test(command) ? (index = "  disconnect [pid]\n", index += "  fork\n", 
                index += "  kill [pid]\n", index += "  memory\n", index += "  ps\n", index += "  title [name]\n", 
                index += "  uptime\n", index += "  exit\n", index += "  close\n", sock.write(index, function() {
                    return resume(sock);
                })) : nyanRegex.test(command) ? (index = "-_-_-_-_-_-_-_,------,      o      \n", 
                index += "_-_-_-_-_-_-_-|   /\\_/\\            \n", index += "-_-_-_-_-_-_-~|__( ^ .^)  +     +  \n", 
                index += '_-_-_-_-_-_-_-""  ""               \n', sock.write(index, function() {
                    return resume(sock);
                })) : sock.write('> unrecognized, try "help"\n', function() {
                    return resume(sock);
                });
            }
            command.replace(commandRegex, "") === my.auth ? (grant = !0, sock.write("> hello master\n", function() {
                return output("client connected"), resume(sock);
            })) : sock.write("> auth required\n", function() {
                return output("client denied"), resume(sock);
            });
        });
    });
    return server.on("error", function(e) {
        "EADDRINUSE" !== e.code && "ECONNREFUSED" !== e.code || (0 == ~~my.listen ? fs.unlink(my.listen, function(err) {
            if (err) throw err;
            return start(!1);
        }) : setTimeout(function() {
            return start(!1);
        }, 1e3));
    }), start(!0);
}

function wrapperUDP(my) {
    var dgram = require("dgram"), mod = load(), keys = Object.keys(mod), ii = keys.length, output = function() {};
    my.output && (output = function(consolle) {
        return console.log(consolle);
    });
    function write(string, sock, next) {
        var message = new Buffer(string);
        return sock.server.send(message, 0, message.length, sock.port, sock.address, function(err) {
            return next ? next(err) : null;
        });
    }
    var next = function(sock, string) {
        return write(string, sock);
    };
    my.json && (next = function(sock, string, object) {
        return write(JSON.stringify(object), sock);
    });
    function start(print) {
        return server.bind(my.listen, function() {
            print && console.log("task manager bound at UDP:" + my.listen);
        });
    }
    var server = dgram.createSocket("udp4", function(buff, sock) {
        sock.server = server;
        for (var index, command = String(buff), workers = cluster.workers, i = 0; i < ii; ++i) {
            var m = mod[keys[i]];
            if (!0 === m.regex.test(command)) return m.body(sock, command, workers, next);
        }
        if (!my.custom || !my.custom.test(command)) return exitRegex.test(command) ? (write("> exit\n", sock, function() {
            return server.close(function() {
                return output("exit");
            });
        }), process.exit(0)) : closeRegex.test(command) ? write("> close\n", sock, function() {
            return server.close(function() {
                return output("close");
            });
        }) : helpRegex.test(command) ? (index = "  disconnect [pid]\n", index += "  fork\n", 
        index += "  kill [pid]\n", index += "  memory\n", index += "  ps\n", index += "  title [name]\n", 
        index += "  uptime\n", index += "  exit\n", write(index += "  close\n", sock)) : nyanRegex.test(command) ? (index = "-_-_-_-_-_-_-_,------,      o      \n", 
        index += "_-_-_-_-_-_-_-|   /\\_/\\            \n", index += "-_-_-_-_-_-_-~|__( ^ .^)  +     +  \n", 
        write(index += '_-_-_-_-_-_-_-""  ""               \n', sock)) : write('> unrecognized, try "help"\n', sock, null);
        my.callback(sock, command);
    });
    return server.on("error", function(e) {
        "EADDRINUSE" !== e.code && "ECONNREFUSED" !== e.code || setTimeout(function() {
            return start(!1);
        }, 1e3);
    }), start(!0);
}

function task(listen, opt) {
    if (!listen) throw new TypeError("listen required");
    var what = Number(listen) || String(listen), options = opt || Object.create(null), my = {
        listen: what,
        output: !0 === options.output,
        auth: !!Boolean(options.auth) && String(options.auth),
        custom: !!Boolean(options.custom) && options.custom,
        callback: options.callback,
        json: Boolean(options.json)
    };
    if (my.custom && "function" == typeof my.callback ? my.custom.source || (my.custom = new RegExp(my.custom)) : my.custom = !1, 
    !0 === Boolean(options.udp)) {
        if (0 == ~~what) throw new TypeError("required a port number for UDP connection");
        return wrapperUDP(my);
    }
    if ("object" == typeof options.tls) {
        if (0 == ~~what) throw new TypeError("required a port number for TLS connection");
        return my.tls = options.tls, wrapperTLS(my);
    }
    return wrapperTCP(my);
}

module.exports = task;
